<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Matrices IV</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="week8_files/libs/clipboard/clipboard.min.js"></script>
<script src="week8_files/libs/quarto-html/quarto.js"></script>
<script src="week8_files/libs/quarto-html/popper.min.js"></script>
<script src="week8_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="week8_files/libs/quarto-html/anchor.min.js"></script>
<link href="week8_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="week8_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="week8_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="week8_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="week8_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-full">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#one-particle" id="toc-one-particle" class="nav-link active" data-scroll-target="#one-particle"><span class="toc-section-number">1</span>  One particle</a>
  <ul class="collapse">
  <li><a href="#hilbert-space" id="toc-hilbert-space" class="nav-link" data-scroll-target="#hilbert-space"><span class="toc-section-number">1.1</span>  Hilbert space</a></li>
  <li><a href="#matrix-representation" id="toc-matrix-representation" class="nav-link" data-scroll-target="#matrix-representation"><span class="toc-section-number">1.2</span>  Matrix Representation</a></li>
  <li><a href="#hamiltonian" id="toc-hamiltonian" class="nav-link" data-scroll-target="#hamiltonian"><span class="toc-section-number">1.3</span>  Hamiltonian</a></li>
  </ul></li>
  <li><a href="#two-particles" id="toc-two-particles" class="nav-link" data-scroll-target="#two-particles"><span class="toc-section-number">2</span>  Two particles</a>
  <ul class="collapse">
  <li><a href="#hilbert-spaces" id="toc-hilbert-spaces" class="nav-link" data-scroll-target="#hilbert-spaces"><span class="toc-section-number">2.1</span>  Hilbert spaces</a></li>
  <li><a href="#matrix-representation-1" id="toc-matrix-representation-1" class="nav-link" data-scroll-target="#matrix-representation-1"><span class="toc-section-number">2.2</span>  Matrix Representation</a>
  <ul class="collapse">
  <li><a href="#kronecker-product" id="toc-kronecker-product" class="nav-link" data-scroll-target="#kronecker-product">Kronecker Product</a></li>
  </ul></li>
  <li><a href="#interacting-spins" id="toc-interacting-spins" class="nav-link" data-scroll-target="#interacting-spins"><span class="toc-section-number">2.3</span>  Interacting Spins</a></li>
  <li><a href="#hamiltonian-1" id="toc-hamiltonian-1" class="nav-link" data-scroll-target="#hamiltonian-1"><span class="toc-section-number">2.4</span>  Hamiltonian</a></li>
  </ul></li>
  <li><a href="#three-particles" id="toc-three-particles" class="nav-link" data-scroll-target="#three-particles"><span class="toc-section-number">3</span>  Three Particles</a>
  <ul class="collapse">
  <li><a href="#hamiltonian-2" id="toc-hamiltonian-2" class="nav-link" data-scroll-target="#hamiltonian-2"><span class="toc-section-number">3.1</span>  Hamiltonian</a></li>
  </ul></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation"><span class="toc-section-number">4</span>  Implementation</a>
  <ul class="collapse">
  <li><a href="#kronecker-product-1" id="toc-kronecker-product-1" class="nav-link" data-scroll-target="#kronecker-product-1"><span class="toc-section-number">4.1</span>  Kronecker product</a></li>
  <li><a href="#two-particles-1" id="toc-two-particles-1" class="nav-link" data-scroll-target="#two-particles-1"><span class="toc-section-number">4.2</span>  Two particles</a>
  <ul class="collapse">
  <li><a href="#three-particles-1" id="toc-three-particles-1" class="nav-link" data-scroll-target="#three-particles-1">Three particles</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#homework" id="toc-homework" class="nav-link" data-scroll-target="#homework"><span class="toc-section-number">5</span>  Homework</a></li>
  </ul>
</nav>
</div>
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Matrices IV</h1>
<p class="subtitle lead">Project: the Schrödinger Eigenvalue Problem</p>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<p>We now turn to the prototypical eigenvalue problem in modern physics, the time-independent Schrödinger equation: <span id="eq-SEQ"><span class="math display">
\hat{H}\ket{\psi}=E\ket{\psi}
\tag{1}</span></span> where <span class="math inline">\hat{H}</span> is the Hamiltonian operator, <span class="math inline">\ket{\psi}</span> is a state vector (called a ket by Dirac) in a Hilbert space, and <span class="math inline">E</span> is the energy.</p>
<p>In practice, when solving <a href="#eq-SEQ">Equation&nbsp;1</a> for a given physical problem, we typically get a differential equation, as we will see later of this course. In the present section, we limit ourselves to the case of one or more particles with spin-half, where there are no orbital degrees of freedom (can be generalizeed to higher spins).</p>
<p>As we will see below, our problem maps onto a (reasonably) straightforward matrix form, where you don’t have to worry about non-matrix features. Thus, the problem of spin-half particles becomes a direct application of the eigenproblem machinery we built earlier.</p>
<section id="one-particle" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> One particle</h1>
<section id="hilbert-space" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="hilbert-space"><span class="header-section-number">1.1</span> Hilbert space</h2>
<p>In quantum mechanics you typically denote the spin angular momentum operator by <span class="math inline">\hat{\boldsymbol{S}}</span>, this being made up of the three Cartesian components <span class="math inline">\hat{S}_x</span>, <span class="math inline">\hat{S}_y</span>, and <span class="math inline">\hat{S}_z</span>. The two most important relations in this context are the ones for the square of the spin operator and for its <span class="math inline">z</span> component: <span class="math display">
\begin{gather*}
\hat{S}^2 \ket{s m_s} = s(s+1) \ket{sm_s} \\
\hat{S}_z \ket{s m_s} = m_s \ket{sm_s}.
\end{gather*}
</span> Note that we have chosen <span class="math inline">\hbar = 1</span> for convenience. Here <span class="math inline">s</span> is the spin, and <span class="math inline">m_s</span> is the azimuthal quantum number (<span class="math inline">m_s = -s, -s+1, \cdots, s</span>).</p>
<p>In the following, we shall focus on spin <span class="math inline">s=1/2</span> systems, which means <span class="math inline">m_s = \pm 1/2</span>, just two possibilities. We shall introduce the notation <span class="math inline">\ket{\uparrow}</span> and <span class="math inline">\ket{\downarrow}</span> for these two states. We have <span class="math display">
\hat{S}_z \ket{\uparrow} = \frac{1}{2}\ket{\uparrow},\quad \hat{S}_z \ket{\downarrow} = -\frac{1}{2}\ket{\downarrow}.
</span> We can thus use <span class="math inline">\ket{\uparrow}</span> and <span class="math inline">\ket{\downarrow}</span> as an orthonormal basis for the Hilbert space.</p>
<p>An arbitrary spin state can thus be written as a linear combination <span class="math display">
\ket{\psi} = \psi_{\uparrow}\ket{\uparrow} + \psi_{\downarrow}\ket{\downarrow} = \sum_{i = \uparrow,\downarrow} \psi_i \ket{i},
</span> where <span class="math inline">\psi_\uparrow = \braket{\uparrow |\psi}</span> and <span class="math inline">\psi_\downarrow = \braket{\downarrow |\psi}</span> are complex numbers.</p>
</section>
<section id="matrix-representation" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="matrix-representation"><span class="header-section-number">1.2</span> Matrix Representation</h2>
<p>We now turn to the matrix representation of spin-half particles. This is very convenient, since it involves <span class="math inline">2 \times 2</span> matrices for spin operators. You may have even heard that a <span class="math inline">2 \times 1</span> column vector (which represents a spin state vector) is called a spinor.</p>
<p>Let’s try to form all the possible matrix elements, sandwiching <span class="math inline">\hat{S}_z</span> between the basis states: this leads to <span class="math inline">\bra{i}\hat{S}_z\ket{j}</span>, where <span class="math inline">i</span> and <span class="math inline">j</span> take on the values <span class="math inline">\uparrow</span> and <span class="math inline">\downarrow</span>. This means that there are four possibilites (i.e., four matrix elements) in total. It then becomes natural to collect them into a <span class="math inline">2 \times 2</span> matrix. Thus, we will group together all the matrix elements and denote the resulting matrix with a bold symbol, <span class="math display">
\boldsymbol{S}_z =
\begin{pmatrix}
\bra{\uparrow}\hat{S}_z\ket{\uparrow} &amp; \bra{\uparrow}\hat{S}_z\ket{\downarrow} \\
\bra{\downarrow}\hat{S}_z\ket{\uparrow} &amp; \bra{\downarrow}\hat{S}_z\ket{\downarrow}
\end{pmatrix}
= \frac{1}{2}
\begin{pmatrix}
1 &amp; 0 \\
0 &amp;  -1
\end{pmatrix}.
</span></p>
<p>Similarly, we can derive other spin operators <span class="math display">
\boldsymbol{S}_x =
\begin{pmatrix}
\bra{\uparrow}\hat{S}_x\ket{\uparrow} &amp; \bra{\uparrow}\hat{S}_x\ket{\downarrow} \\
\bra{\downarrow}\hat{S}_x\ket{\uparrow} &amp; \bra{\downarrow}\hat{S}_x\ket{\downarrow}
\end{pmatrix}
= \frac{1}{2}
\begin{pmatrix}
0 &amp; 1\\
1 &amp; 0
\end{pmatrix}
</span> and <span class="math display">
\boldsymbol{S}_y =
\begin{pmatrix}
\bra{\uparrow}\hat{S}_y\ket{\uparrow} &amp; \bra{\uparrow}\hat{S}_y\ket{\downarrow} \\
\bra{\downarrow}\hat{S}_y\ket{\uparrow} &amp; \bra{\downarrow}\hat{S}_y\ket{\downarrow}
\end{pmatrix}
= \frac{1}{2}
\begin{pmatrix}
0 &amp; -i\\
i &amp; 0
\end{pmatrix}.
</span></p>
<p>We can introduce the so-called <em>Pauli matrices</em>: <span class="math display">
\boldsymbol{\sigma}_x =
\begin{pmatrix}
0 &amp; 1\\
1 &amp; 0
\end{pmatrix},\quad
\boldsymbol{\sigma}_y =
\begin{pmatrix}
0 &amp; -i\\
i &amp; 0
\end{pmatrix},\quad
\boldsymbol{\sigma}_z =
\begin{pmatrix}
1 &amp; 0\\
0 &amp; -1
\end{pmatrix}.
</span> You should probably memorize these matrices.</p>
<p>We now turn to the representation of the state vectors. Let’s first approach this as a linear algebra problem: we need to diagonalize the <span class="math inline">2\times 2</span> matrix <span class="math inline">\boldsymbol{S}_z</span>. As you already know well after studying the present section, that implies finding the eigenvalues (which turn out to be <span class="math inline">\pm 1/2</span>) and the eigenvectors, which we calculate to be <span class="math display">
\ket{\uparrow} \sim \boldsymbol{\zeta}_\uparrow =
\begin{pmatrix}
1 \\ 0
\end{pmatrix}, \quad
\ket{\downarrow} \sim \boldsymbol{\zeta}_\downarrow =
\begin{pmatrix}
0 \\ 1
\end{pmatrix}.
</span></p>
<p>Since the matrix we were diagonalizing was 2 by 2, it comes as no surprise that the eigenvectors are <span class="math inline">2\times 1</span> column vectors. You should test your understanding by finding the eigenvectors corresponding to, say, <span class="math inline">\boldsymbol{S}_y</span>.</p>
<p>With this, we are no longer dealing with operators and state vectors (no hats and no kets), but with matrices and column vectors, respectively. As a result, relations that in the Hilbert-space language involved actions on kets, now turn into relations involving matrices. For example, <span class="math display">
\boldsymbol{S}_z \boldsymbol{\zeta}_\uparrow = \frac{1}{2}\boldsymbol{\zeta}_\uparrow
</span></p>
<p>We can combine our two eigenvectors to produce the matrix representation of an arbitrary spin state <span class="math display">
\boldsymbol{\psi} = \psi_{\uparrow}\boldsymbol{\zeta}_\uparrow + \psi_{\downarrow}\boldsymbol{\zeta}_\downarrow = (\psi_\uparrow \quad \psi_\downarrow)^T.
</span></p>
</section>
<section id="hamiltonian" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="hamiltonian"><span class="header-section-number">1.3</span> Hamiltonian</h2>
<p>We start with the eigenvalue equation for operators and kets <span class="math display">
\hat{H}\ket{\psi} = E\ket{\psi}.
</span> Using the completeness of the basis, <span class="math inline">\hat{\mathcal{I}} = \ket{\uparrow}\bra{\uparrow} + \ket{\downarrow}\bra{\downarrow}</span>, we have <span class="math display">
\hat{H}\ket{\uparrow}\bra{\uparrow}\psi\rangle + \hat{H}\ket{\downarrow}\bra{\downarrow}\psi\rangle = E\ket{\psi}.
</span></p>
<p>Multiplying from the left by <span class="math inline">\bra{\uparrow}</span>, we obtain <span class="math display">
\bra{\uparrow}\hat{H}\ket{\uparrow}\bra{\uparrow}\psi\rangle + \bra{\uparrow}\hat{H}\ket{\downarrow}\bra{\downarrow}\psi\rangle = E\bra{\uparrow}\psi\rangle.
</span> One can repeat this by using <span class="math inline">\bra{\downarrow}</span> as well. Then we obtain a matrix equation <span class="math display">
\boldsymbol{H}\boldsymbol{\psi} = E \boldsymbol{\psi},
</span> where <span class="math inline">\boldsymbol{H}</span> is the Hamiltonian matrix with matrix elements <span class="math inline">\bra{i}\hat{H}\ket{j}</span> for <span class="math inline">i,j = \uparrow, \downarrow</span>.</p>
<p>As an example, let us consider a spin-half particle interacting with an external magnetic field <span class="math inline">\boldsymbol{B}</span>. Associated with the spin angular momentum <span class="math inline">\hat{\boldsymbol{S}}</span> there will be a spin magnetic moment operator, <span class="math inline">\hat{\boldsymbol{\mu}}</span>: since this operator needs to be a combination of the spin operators and the identity (and we know it has to be a vector operator), it follows that <span class="math inline">\hat{\boldsymbol{\mu}}</span> is proportional to <span class="math inline">\hat{\boldsymbol{S}}</span>. It is customary to write the proportionality between the two operators as follows: <span class="math display">
\hat{\boldsymbol{\mu}} = g\left(\frac{q}{2m}\right)\hat{\boldsymbol{S}}
</span> where <span class="math inline">q</span> is the electric charge of the particle and <span class="math inline">m</span> is its mass. The proportionality constant is known as the g-factor: its value is roughly <span class="math inline">-2</span> for electrons.</p>
<p>The hamiltonian then can be written as <span class="math display">
\hat{H} = -\hat{\boldsymbol{\mu}} \cdot \boldsymbol{B} =-\frac{gqB}{2m}\hat{\boldsymbol{S}}\cdot \boldsymbol{B}.
</span></p>
<p>We then took our <span class="math inline">z</span> axis as pointing in the direction of the magnetic field. Combining our earlier point about how to go from operators to matrices, with the explicit matrix representation of <span class="math inline">\hat{\boldsymbol{S}}_z</span>, as <span class="math display">
\boldsymbol{H} = -\frac{gqB}{4m}\boldsymbol{\sigma}_z
= -\frac{gqB}{4m}
\begin{pmatrix}
1 &amp; 0 \\
0 &amp; -1
\end{pmatrix}.
</span></p>
</section>
</section>
<section id="two-particles" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Two particles</h1>
<section id="hilbert-spaces" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="hilbert-spaces"><span class="header-section-number">2.1</span> Hilbert spaces</h2>
<p>For a single spin-half particle, we can introduce two states <span class="math inline">\ket{\uparrow}, \ket{\downarrow}</span> forming the basis of its Hilbert space. For a system of two spin-half particles, we should be careful about the notation. We need to label these two particles. Let’s call them particle I and particle II. Particle I involves a vector space which is spanned by the two kets <span class="math inline">\ket{\uparrow^{(I)}}</span> and <span class="math inline">\ket{\downarrow^{(I)}}</span>. Similarly, the Hilbert space of the second particle is spanned by the two kets <span class="math inline">\ket{\uparrow^{(II)}}</span> and <span class="math inline">\ket{\downarrow}^{(II)}</span>.</p>
<p>We now wish to start from these single-particle vector spaces and generalize to a two-particle space. To do this, we employ the concept of a tensor product (denoted by <span class="math inline">\otimes</span>): this allows us to express the product between state vectors belonging to different Hilbert spaces. In short, the two-particle Hilbert space is a four-dimensional complex vector space which is spanned by the vectors: <span class="math display">
\begin{gather*}
\ket{\uparrow^{(I)}}\otimes\ket{\uparrow^{(II)}} \equiv \ket{\uparrow\uparrow}, \quad \ket{\uparrow^{(I)}}\otimes\ket{\downarrow^{(II)}} \equiv \ket{\uparrow\downarrow} \\
\ket{\downarrow^{(I)}}\otimes\ket{\uparrow^{(II)}} \equiv \ket{\downarrow\uparrow}, \quad \ket{\downarrow^{(I)}}\otimes\ket{\downarrow^{(II)}} \equiv \ket{\downarrow\downarrow}.
\end{gather*}
</span></p>
<p>Thus, we can write the basis of the two-state Hilbert space in a compact form as <span class="math inline">\ket{i}</span>, with <span class="math inline">i = \uparrow\uparrow, \uparrow\downarrow, \downarrow\uparrow, \downarrow\downarrow</span>.</p>
<p>In terms of the Hilbert spaces themselves, we started from the space of the first particle (<span class="math inline">\mathscr{H}^{(I)}</span>) and the space of the second particle (<span class="math inline">\mathscr{H}^{(II)}</span>) and have produced the larger, two-particle Hilbert space <span class="math inline">\mathscr{H}^{(I)}\otimes\mathscr{H}^{(II)}</span>. The four state vectors <span class="math inline">\ket{i^{(I)}}\otimes\ket{j^{(II)}}</span>, <span class="math inline">i,j = \uparrow, \downarrow</span> form the <em>product basis</em> of this Hilbert space <span class="math inline">\mathscr{H}^{(I)}\otimes\mathscr{H}^{(II)}</span>.</p>
<p>Let us turn to the operators in the two-particle Hilbert space, focusing on the <span class="math inline">z</span>-projection operator for concreteness. We already know the one-particle operator <span class="math inline">\hat{S}_z^{(I)}</span> which acts on the vector of particle I and, similarly, the one-particle operator <span class="math inline">\hat{S}_z^{(II)}</span> which acts on the vector space of particle II. Each of these operators measures the <span class="math inline">z</span>-projection of the spin for the respective particle. What we wish to do is come up with operators for the composite system. We do this by, again, employing the tensor product. For example <span class="math display">
\hat{S}_{1z} = \hat{S}_z^{(I)} \otimes \hat{\mathcal{I}}^{(II)}.
</span> On the left-hand side we are introducing a new entity, <span class="math inline">\hat{S}_{Iz}</span>, acting on the two-particle Hilbert space. Instead, it is made up of two one-particle operators, each of which knows how to act on its respective one-particle space. It should be easy to see why we have taken the tensor product with the identity operator <span class="math inline">\hat{\mathcal{I}}</span>: the two-particle operator <span class="math inline">\hat{S}_{Iz}</span> measures the <span class="math inline">z</span> component of the spin for particle I, so it does nothing to any particle-II ket it encounters. In complete analogy to this, the two-particle operator that measures the <span class="math inline">z</span> component of the spin for particle II is: <span class="math display">
\hat{S}_{IIz} =\hat{\mathcal{I}}^{(I)} \otimes \hat{S}_z^{(II)}.
</span></p>
<p>Let’s see what happens when a two-particle operator acts on a given two-particle state vector: <span class="math display">
\hat{S}_{IIz}\ket{\uparrow\downarrow}  = (\hat{\mathcal{I}}^{(I)}\otimes \hat{S}_z^{(II)})(\ket{\uparrow^{(I)}}\otimes\ket{\downarrow^{(II)}}) = \ket{\uparrow^{(I)}} \otimes (-\frac{1}{2}\ket{\downarrow^{(II)}}) = -\frac{1}{2}\ket{\uparrow\downarrow}.
</span></p>
<p>Finally, an arbitrary spin state can be expressed as a linear superposition: <span class="math display">
\ket{\psi} = \sum_{a}\psi_a \ket{a}, \quad a = \uparrow\uparrow, \uparrow\downarrow, \downarrow\uparrow, \downarrow\downarrow.
</span></p>
<p>As a remark, in QM we typically consider the <em>coupled representation</em> where we need to add angular momenta using the Clebsh-Gordan coefficients. For the specific case of two spin-half particles, this leads to one spin-singlet state and a spin-triplet (made up of three states). In contradistinction to this, here we are interested in the uncoupled representation, where we consider the two-particle system as being made up of two individual particles. Below, we will show you how to build up the matrix representation of a two-particle operator using the matrix representation of one-particle operators: this will give us a tool that is then trivial to generalize to larger numbers of particles.</p>
</section>
<section id="matrix-representation-1" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="matrix-representation-1"><span class="header-section-number">2.2</span> Matrix Representation</h2>
<p>Turning to the matrix representation of two spin-half particles, you will not be surprised to hear that it involves <span class="math inline">4 \times 4</span> matrices for spin operators and <span class="math inline">4\times 1</span> column vectors for the state vectors.</p>
<p>We shall use the two-particle basis <span class="math inline">\ket{\uparrow\uparrow},\ket{\uparrow\downarrow},\ket{\downarrow\uparrow},\ket{\downarrow\downarrow}</span>, corresponding to the following column vectors <span class="math display">
\boldsymbol{\zeta}_{\uparrow\uparrow} =
\begin{pmatrix}
1 \\ 0 \\ 0 \\ 0
\end{pmatrix}, \quad
\boldsymbol{\zeta}_{\uparrow\downarrow} =
\begin{pmatrix}
0 \\ 1 \\ 0 \\ 0
\end{pmatrix}, \quad
\boldsymbol{\zeta}_{\downarrow\uparrow} =
\begin{pmatrix}
0 \\ 0 \\ 1 \\ 0
\end{pmatrix}, \quad
\boldsymbol{\zeta}_{\downarrow\downarrow} =
\begin{pmatrix}
0 \\ 0 \\ 0 \\ 1
\end{pmatrix}.
</span> For an arbitrary state vector, we can represent it as the following column vector <span class="math display">
\boldsymbol{\psi} = \psi_{\uparrow\uparrow}\boldsymbol{\zeta}_{\uparrow\uparrow} + \psi_{\uparrow\downarrow}\boldsymbol{\zeta}_{\uparrow\downarrow}
+ \psi_{\downarrow\uparrow}\boldsymbol{\zeta}_{\downarrow\uparrow} + \psi_{\downarrow\downarrow}\boldsymbol{\zeta}_{\downarrow\downarrow}=
\begin{pmatrix}
\psi_{\uparrow\uparrow} \\ \psi_{\uparrow\downarrow} \\ \psi_{\downarrow\uparrow} \\ \psi_{\downarrow\downarrow}
\end{pmatrix}.
</span></p>
<p>We have seen that the two-particle basis can be constructed via the tensor product of single-particle basis. For matrices, there exists a similar operation that builds larger matrices from smaller matrices. We shall introduce this operation below.</p>
<section id="kronecker-product" class="level3">
<h3 class="anchored" data-anchor-id="kronecker-product">Kronecker Product</h3>
<p>The <em>Kronecker product</em> between two matrices is denoted similarly as the tensor product. Let us take an <span class="math inline">n\times n</span> matrix <span class="math inline">\boldsymbol{U}</span> and a <span class="math inline">p \times p</span> matrix <span class="math inline">\boldsymbol{V}</span>. The Kronecker product <span class="math inline">\boldsymbol{W} = \boldsymbol{U}\otimes\boldsymbol{V}</span> is the <span class="math inline">np\times np</span> matrix: <span class="math display">
\boldsymbol{W} = \boldsymbol{U} \otimes \boldsymbol{V} =
\begin{pmatrix}
U_{00}\boldsymbol{V} &amp; U_{01}\boldsymbol{V} &amp; \dots &amp; U_{0,n-1}\boldsymbol{V} \\
U_{10}\boldsymbol{V} &amp; U_{11}\boldsymbol{V} &amp; \dots &amp; U_{1,n-1}\boldsymbol{V} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
U_{n-1,0}\boldsymbol{V} &amp; U_{n-1,1}\boldsymbol{V} &amp; \dots &amp; U_{n-1,n-1}\boldsymbol{V}
\end{pmatrix}.
</span></p>
<p>The presence of a <span class="math inline">\boldsymbol{V}</span> in each slot is to be interpreted as follows: to produce <span class="math inline">\boldsymbol{U}\otimes \boldsymbol{V}</span>, take each element of <span class="math inline">\boldsymbol{U}</span>, namely <span class="math inline">U_{ik}</span>, and replace it by <span class="math inline">U_{ik}\boldsymbol{V}</span>, which is a <span class="math inline">p \times p</span> matrix. For example, we have <span class="math display">
\zeta_{\uparrow\downarrow} =
\begin{pmatrix}
1 \\ 0
\end{pmatrix}
\otimes
\begin{pmatrix}
0 \\ 1
\end{pmatrix}
=
\begin{pmatrix}
1\begin{pmatrix} 0 \\ 1 \end{pmatrix} \\ 0 \begin{pmatrix} 0 \\ 1 \end{pmatrix}
\end{pmatrix}
=
\begin{pmatrix}
0 \\ 1 \\ 0 \\ 0
\end{pmatrix}.
</span></p>
<p>We can also use Kronecker product to build matrix representation of <span class="math inline">\hat{S}_{Iz}</span>. We have <span class="math display">
\boldsymbol{S}_{Iz} = \boldsymbol{S}_z \otimes \boldsymbol{I} = \frac{1}{2}
\begin{pmatrix}
1 &amp; 0 \\
0 &amp; -1
\end{pmatrix}
\otimes
\begin{pmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{pmatrix}
=
\frac{1}{2}
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; -1
\end{pmatrix}.
</span></p>
<p>Now let us try to implement the Kronecker product programmatically, for general matrices <span class="math inline">\boldsymbol{U}</span> and <span class="math inline">\boldsymbol{V}</span>. We need an equation connecting the indices of the <span class="math inline">\boldsymbol{U}</span> and <span class="math inline">\boldsymbol{V}</span> matrix elements, on the one hand, with the indices of the <span class="math inline">\boldsymbol{W}</span> matrix, on the other. This is: <span class="math display">
W_{ab} =(\boldsymbol{U}\otimes \boldsymbol{V})_{ab} = U_{ik}V_{jl}, \quad a = pi+j, b = pk + i
</span> where <span class="math inline">p</span> is the dimension of <span class="math inline">\boldsymbol{V}</span>. The original four indices take on the values: <span class="math display">
i = 0,1,\dots, n-1, \quad k = 0, 1, \dots, n-1, \quad j = 0, 1, \dots, p-1, \quad l = 0,1,\dots, p-1.
</span> As a result, the new indices takes on the values <span class="math display">
a = 0,1,\dots,np-1, \quad b = 0,1,\dots, np-1.
</span></p>
<p>You should spend some time thinking about our new equation: you will benefit from applying it by hand to one or two simple cases (say, the Kronecker product of a <span class="math inline">2 \times 2</span> matrix with a <span class="math inline">3 \times 3</span> matrix).</p>
</section>
</section>
<section id="interacting-spins" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="interacting-spins"><span class="header-section-number">2.3</span> Interacting Spins</h2>
<p>Let us now consider the interaction between two spins: <span class="math display">
\hat{\boldsymbol{S}}_{I} \cdot \hat{\boldsymbol{S}}_{II} = \hat{S}_{Ix}\hat{S}_{IIx} + \hat{S}_{Iy}\hat{S}_{IIy} +\hat{S}_{Iz}\hat{S}_{IIz}.
</span></p>
<p>The matrix representation of this interaction can be constructed with Kronecker product <span class="math display">
\boldsymbol{S}_{I\cdot II} = \{\bra{a}\hat{\boldsymbol{S}}_{I} \cdot \hat{\boldsymbol{S}}_{II} \ket{b}\}
= \boldsymbol{S}_{x}\otimes\boldsymbol{S}_{x} + \boldsymbol{S}_{y}\otimes\boldsymbol{S}_{y} + \boldsymbol{S}_{z}\otimes\boldsymbol{S}_{z}.
</span></p>
</section>
<section id="hamiltonian-1" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="hamiltonian-1"><span class="header-section-number">2.4</span> Hamiltonian</h2>
<p>We end our discussion of two spin-half particles with the Schrödinger equation: <span class="math display">
\hat{H}\ket{\psi} = E\ket{\psi}.
</span> We can use its matrix representation for numerical implementation <span class="math display">
\boldsymbol{H}\boldsymbol{\psi} = E \boldsymbol{\psi},
</span> where <span class="math inline">\boldsymbol{H}</span> is a <span class="math inline">4\times 4</span> matrix, and <span class="math inline">\psi</span> is a <span class="math inline">4 \times 1</span> column vector.</p>
<p>A Hamiltonian describing the interaction between two spins in presence of external magnetic field is of the following form <span class="math display">
\begin{align*}
\hat{H} &amp;= -\frac{g_I q_I B}{2m_I}\hat{S}_{Iz} - \frac{g_{II} q_{II} B}{2m_{II}}\hat{S}_{IIz} + \gamma \hat{\boldsymbol{S}}_{I} \cdot \hat{\boldsymbol{S}}_{II} \\
&amp; = -\omega_{I}\hat{S}_{Iz} - \omega_{II}\hat{S}_{IIz} + \gamma (\hat{S}_{Ix}\hat{S}_{IIx} + \hat{S}_{Iy}\hat{S}_{IIy} +\hat{S}_{Iz}\hat{S}_{IIz}).
\end{align*}
</span></p>
<p>Based on this, we can construct its matrix representation using Kronecker product <span id="eq-two-spin-tensor"><span class="math display">
\boldsymbol{H}  = -\omega_I \boldsymbol{S}_z\otimes\boldsymbol{I} - \omega_{II}\boldsymbol{I}\otimes\boldsymbol{S}_z + \gamma(\boldsymbol{S}_{x}\otimes\boldsymbol{S}_x + \boldsymbol{S}_{y}\otimes\boldsymbol{S}_y + \boldsymbol{S}_{z}\otimes\boldsymbol{S}_z).
\tag{2}</span></span></p>
<p>In your homework, you will show that <span id="eq-two-spin"><span class="math display">
\boldsymbol{H} = -\frac{1}{2}
\begin{pmatrix}
\omega_{I}+\omega_{II}-\frac{\gamma}{2} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp;\omega_{I} - \omega_{II}+\frac{\gamma}{2} &amp; -\gamma &amp; 0 \\
0 &amp; -\gamma &amp; -\omega_I+\omega_{II}+\frac{\gamma}{2} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; -\omega_I-\omega_{II}-\frac{\gamma}{2}
\end{pmatrix}
\tag{3}</span></span></p>
</section>
</section>
<section id="three-particles" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Three Particles</h1>
<p>We will now see the benefits of the theoretical machinery we established in the previous sections. We can now study the problem of three spin-half particles, interacting with a magnetic field and with each other. The matrix formulation of this problem gives rise to <span class="math inline">8 \times 8</span> matrices (so 64 matrix elements per matrix): since there are three particles and three Cartesian coordinates, we need to deal with at least nine matrices, each of which is <span class="math inline">8 \times 8</span>. In other words, this is not a task that is comfortably carried out using paper and pencil, which is why it doesn’t appear in QM textbooks traditionally.</p>
<p>The basis for the three-particle Hilbert space can be chosen naturally as <span class="math display">
\ket{i^{I}}\otimes\ket{j^{II}}\otimes\ket{k^{III}} \equiv \ket{\mu}
</span> with all possible <span class="math display">
\mu = \uparrow\uparrow\uparrow, \uparrow\uparrow\downarrow, \uparrow\downarrow\uparrow, \downarrow\uparrow\uparrow, \uparrow\downarrow\downarrow, \downarrow\uparrow\downarrow, \downarrow\downarrow\uparrow,\downarrow\downarrow\downarrow.
</span> You may thus think <span class="math inline">\mu</span> as the ordered triple <span class="math inline">(i,j,k)</span>.</p>
<p>The operators acting on the three-particle Hilbert space can thus be constructed, for example, <span class="math display">
\hat{S}_{Iz} = \hat{S}_{z}^{(I)}\otimes\hat{\mathcal{I}}^{(II)}\otimes\hat{\mathcal{I}}^{(III)},
</span> as the <span class="math inline">z</span> projection for the first particle. Similarly, the matrix representation of this operator can be constructed with Kronecker product <span class="math display">
\boldsymbol{S}_{1z} = \boldsymbol{S}_z \otimes \boldsymbol{I} \otimes \boldsymbol{I}.
</span></p>
<p>Here, we see two Kronecker products in a row, so you may be wondering how to interpret such an operation. Luckily, the Kronecker product is <em>associative</em>: <span class="math display">
(\boldsymbol{T}\otimes \boldsymbol{U})\otimes \boldsymbol{V} =
\boldsymbol{T} \otimes (\boldsymbol{U} \otimes \boldsymbol{V})
</span> meaning that you simply carry out one Kronecker product after the other and it doesn’t matter which Kronecker product you carry out first. (<strong>Note that the Kronecker product is not commutative: <span class="math inline">\boldsymbol{U}\otimes \boldsymbol{V} \neq \boldsymbol{V} \otimes \boldsymbol{U}</span></strong>).</p>
<section id="hamiltonian-2" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="hamiltonian-2"><span class="header-section-number">3.1</span> Hamiltonian</h2>
<p>With these preparations, let us consider the following Hamiltonian <span class="math display">
\hat{H} = -\sum_{\alpha=I,II,III} \omega_\alpha \hat{S}_{\alpha z}
+ \gamma \sum_{\alpha&lt;\beta}\hat{\boldsymbol{S}}_{\alpha} \cdot \hat{\boldsymbol{S}}_{\beta}
</span> which describes three interacting spins in an external magnetic field. Note that in the second summation, the two indices have to satisfy <span class="math inline">\alpha &lt; \beta</span>, and hence the only possible <span class="math inline">(\alpha,\beta)</span> pairs are <span class="math inline">(I,II)</span>, <span class="math inline">(II,III)</span>, and <span class="math inline">(I,III)</span>.</p>
<p>The matrix representation of this Hamiltonian can be constructed via the Kronecker product <span class="math display">
\boldsymbol{H} = -\sum_{\alpha = I,II, III}\boldsymbol{S}_{\alpha z}
+ \gamma\sum_{\alpha&lt;\beta}\boldsymbol{S}_{\alpha\cdot\beta},
</span> where <span class="math display">
\begin{gather*}
\boldsymbol{S}_{Iz} = \boldsymbol{S}_z \otimes \boldsymbol{I} \otimes \boldsymbol{I} \\
\boldsymbol{S}_{IIz} = \boldsymbol{I} \otimes \boldsymbol{S}_z \otimes \boldsymbol{I} \\
\boldsymbol{S}_{IIIz} = \boldsymbol{I}  \otimes \boldsymbol{I} \otimes \boldsymbol{S}_z
\end{gather*}
</span> and <span class="math display">
\begin{gather*}
\boldsymbol{S}_{I \cdot II} =
\boldsymbol{S}_x\otimes\boldsymbol{S}_x\otimes \boldsymbol{I} +
\boldsymbol{S}_y\otimes\boldsymbol{S}_y\otimes \boldsymbol{I} +
\boldsymbol{S}_z\otimes\boldsymbol{S}_z\otimes \boldsymbol{I} =
\sum_{w=x,y,z}\boldsymbol{S}_{I w}\boldsymbol{S}_{II w}
\\
\boldsymbol{S}_{II \cdot III} =
\boldsymbol{I}\otimes \boldsymbol{S}_x\otimes\boldsymbol{S}_x +
\boldsymbol{I}\otimes \boldsymbol{S}_y\otimes\boldsymbol{S}_y +
\boldsymbol{I}\otimes \boldsymbol{S}_z\otimes\boldsymbol{S}_z =
\sum_{w=x,y,z}\boldsymbol{S}_{II w}\boldsymbol{S}_{III w}
  \\
\boldsymbol{S}_{I \cdot III} =
\boldsymbol{S}_x\otimes\boldsymbol{I}\otimes \boldsymbol{S}_x +
\boldsymbol{S}_y\otimes\boldsymbol{I}\otimes \boldsymbol{S}_y +
\boldsymbol{S}_z\otimes\boldsymbol{I}\otimes \boldsymbol{S}_z =
\sum_{w=x,y,z}\boldsymbol{S}_{I w}\boldsymbol{S}_{III w}.
\end{gather*}
</span></p>
<p>Note that here we explored the property of the Kronecker product (homework) <span class="math display">
(\boldsymbol{A}\otimes \boldsymbol{B})(\boldsymbol{C}\otimes \boldsymbol{D})
= (\boldsymbol{A}\boldsymbol{C}) \otimes (\boldsymbol{B}\boldsymbol{D}).
</span></p>
</section>
</section>
<section id="implementation" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Implementation</h1>
<section id="kronecker-product-1" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="kronecker-product-1"><span class="header-section-number">4.1</span> Kronecker product</h2>
<p>We first implement the Kronecker product in the following code.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> paulimatrices():</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    sigx <span class="op">=</span> np.array([<span class="fl">0.</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>]).reshape(<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    sigy <span class="op">=</span> np.array([<span class="fl">0.</span>,<span class="op">-</span><span class="ot">1j</span>,<span class="ot">1j</span>,<span class="dv">0</span>]).reshape(<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    sigz <span class="op">=</span> np.array([<span class="fl">1.</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>]).reshape(<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sigx, sigy, sigz</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kron(U,V):</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> U.shape[<span class="dv">0</span>]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> V.shape[<span class="dv">0</span>]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    W <span class="op">=</span> np.zeros((n<span class="op">*</span>p,n<span class="op">*</span>p), dtype<span class="op">=</span>np.complex64)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(p):</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(p):</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>                    W[p<span class="op">*</span>i<span class="op">+</span>j,p<span class="op">*</span>k<span class="op">+</span>l] <span class="op">=</span> U[i,k]<span class="op">*</span>V[j,l]</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> W</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">'__main__'</span>:</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    sigx, sigy, sigz <span class="op">=</span> paulimatrices()</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    allones <span class="op">=</span> np.ones((<span class="dv">3</span>,<span class="dv">3</span>))</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    kronprod <span class="op">=</span> kron(sigx,allones)<span class="op">;</span> <span class="bu">print</span>(kronprod.real)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[0. 0. 0. 1. 1. 1.]
 [0. 0. 0. 1. 1. 1.]
 [0. 0. 0. 1. 1. 1.]
 [1. 1. 1. 0. 0. 0.]
 [1. 1. 1. 0. 0. 0.]
 [1. 1. 1. 0. 0. 0.]]</code></pre>
</div>
</div>
</section>
<section id="two-particles-1" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="two-particles-1"><span class="header-section-number">4.2</span> Two particles</h2>
<p>We implement the Hamiltonian for two spins in the following. This program also calls the previous codes for calculating eigenvalues using QR method (<code>qrmet()</code>). The inputs for <code>twospins(omI,omII,gam)</code> are <span class="math inline">\omega_I, \omega_{II}, \gamma</span>.</p>
<p>Note that we first call <code>paulimatrices()</code> to get a list of Pauli matrices. We then use list comprehension to store the <span class="math inline">x,y,z</span> components of <span class="math inline">\boldsymbol{S}_I</span> as a list in <code>SIs</code>.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> twospins(omI,omII,gam):</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    hbar <span class="op">=</span> <span class="fl">1.</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    paulis <span class="op">=</span> paulimatrices()</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    iden <span class="op">=</span> np.identity(<span class="dv">2</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    SIs <span class="op">=</span> [hbar<span class="op">*</span>kron(pa,iden)<span class="op">/</span><span class="dv">2</span> <span class="cf">for</span> pa <span class="kw">in</span> paulis]</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    SIIs <span class="op">=</span> [hbar<span class="op">*</span>kron(iden,pa)<span class="op">/</span><span class="dv">2</span> <span class="cf">for</span> pa <span class="kw">in</span> paulis]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    SIdotII <span class="op">=</span> <span class="bu">sum</span>([SIs[i]<span class="op">@</span>SIIs[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>)])</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> <span class="op">-</span>omI<span class="op">*</span>SIs[<span class="dv">2</span>] <span class="op">-</span> omII<span class="op">*</span>SIIs[<span class="dv">2</span>] <span class="op">+</span> gam<span class="op">*</span>SIdotII</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> H.real</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> H</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> paulimatrices():</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    sigx <span class="op">=</span> np.array([<span class="fl">0.</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>]).reshape(<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    sigy <span class="op">=</span> np.array([<span class="fl">0.</span>,<span class="op">-</span><span class="ot">1j</span>,<span class="ot">1j</span>,<span class="dv">0</span>]).reshape(<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    sigz <span class="op">=</span> np.array([<span class="fl">1.</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>]).reshape(<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sigx, sigy, sigz</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kron(U,V):</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> U.shape[<span class="dv">0</span>]</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> V.shape[<span class="dv">0</span>]</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    W <span class="op">=</span> np.zeros((n<span class="op">*</span>p,n<span class="op">*</span>p), dtype<span class="op">=</span>np.complex64)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(p):</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(p):</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>                    W[p<span class="op">*</span>i<span class="op">+</span>j,p<span class="op">*</span>k<span class="op">+</span>l] <span class="op">=</span> U[i,k]<span class="op">*</span>V[j,l]</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> W</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> qrmet(inA,kmax<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> np.copy(inA)</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,kmax):</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>        Q, R <span class="op">=</span> qrdec(A)</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>        A <span class="op">=</span> R<span class="op">@</span>Q</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(k, np.diag(A))</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>    qreigvals <span class="op">=</span> np.diag(A)</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> qreigvals</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> qrdec(A):</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> A.shape[<span class="dv">0</span>]</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>    Ap <span class="op">=</span> np.copy(A)</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> np.zeros((n,n))</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> np.zeros((n,n))</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(j):</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>            R[i,j] <span class="op">=</span> Q[:,i]<span class="op">@</span>A[:,j]</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>            Ap[:,j] <span class="op">-=</span> R[i,j]<span class="op">*</span>Q[:,i]</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>        R[j,j] <span class="op">=</span> mag(Ap[:,j])</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>        Q[:,j] <span class="op">=</span> Ap[:,j]<span class="op">/</span>R[j,j]</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Q, R</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mag(xs):</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.sqrt(np.<span class="bu">sum</span>(xs<span class="op">*</span>xs))</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">'__main__'</span>:</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> twospins(<span class="fl">1.</span>,<span class="fl">2.</span>,<span class="fl">0.5</span>)</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>    qreigvals <span class="op">=</span> qrmet(H)<span class="op">;</span> <span class="bu">print</span>(qreigvals)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[-1.375      -0.68401701  0.434017    1.625     ]</code></pre>
</div>
</div>
<section id="three-particles-1" class="level3">
<h3 class="anchored" data-anchor-id="three-particles-1">Three particles</h3>
<p>Let us now implement the Hamiltonian for three particles.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> threespins(omI,omII,omIII,gam):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    hbar <span class="op">=</span> <span class="fl">1.</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    paulis <span class="op">=</span> paulimatrices()</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    iden <span class="op">=</span> np.identity(<span class="dv">2</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    SIs <span class="op">=</span> [hbar<span class="op">*</span>kron(kron(pa,iden),iden)<span class="op">/</span><span class="dv">2</span> <span class="cf">for</span> pa <span class="kw">in</span> paulis]</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    SIIs <span class="op">=</span> [hbar<span class="op">*</span>kron(kron(iden,pa),iden)<span class="op">/</span><span class="dv">2</span> <span class="cf">for</span> pa <span class="kw">in</span> paulis]</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    SIIIs <span class="op">=</span> [hbar<span class="op">*</span>kron(kron(iden,iden),pa)<span class="op">/</span><span class="dv">2</span> <span class="cf">for</span> pa <span class="kw">in</span> paulis]</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    SIdotII <span class="op">=</span> <span class="bu">sum</span>([SIs[i]<span class="op">@</span>SIIs[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>)])</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    SIdotIII <span class="op">=</span> <span class="bu">sum</span>([SIs[i]<span class="op">@</span>SIIIs[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>)])</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    SIIdotIII <span class="op">=</span> <span class="bu">sum</span>([SIIs[i]<span class="op">@</span>SIIIs[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>)])</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> <span class="op">-</span>omI<span class="op">*</span>SIs[<span class="dv">2</span>] <span class="op">-</span> omII<span class="op">*</span>SIIs[<span class="dv">2</span>] <span class="op">-</span> omIII<span class="op">*</span>SIIIs[<span class="dv">2</span>]</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    H <span class="op">+=</span> gam<span class="op">*</span>(SIdotII<span class="op">+</span>SIdotIII<span class="op">+</span>SIIdotIII)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> H.real</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> H</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> paulimatrices():</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    sigx <span class="op">=</span> np.array([<span class="fl">0.</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">0</span>]).reshape(<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    sigy <span class="op">=</span> np.array([<span class="fl">0.</span>,<span class="op">-</span><span class="ot">1j</span>,<span class="ot">1j</span>,<span class="dv">0</span>]).reshape(<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    sigz <span class="op">=</span> np.array([<span class="fl">1.</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>]).reshape(<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sigx, sigy, sigz</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> kron(U,V):</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> U.shape[<span class="dv">0</span>]</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> V.shape[<span class="dv">0</span>]</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>    W <span class="op">=</span> np.zeros((n<span class="op">*</span>p,n<span class="op">*</span>p), dtype<span class="op">=</span>np.complex64)</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(p):</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(p):</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>                    W[p<span class="op">*</span>i<span class="op">+</span>j,p<span class="op">*</span>k<span class="op">+</span>l] <span class="op">=</span> U[i,k]<span class="op">*</span>V[j,l]</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> W</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> qrmet(inA,kmax<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> np.copy(inA)</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,kmax):</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>        Q, R <span class="op">=</span> qrdec(A)</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>        A <span class="op">=</span> R<span class="op">@</span>Q</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(k, np.diag(A))</span></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>    qreigvals <span class="op">=</span> np.diag(A)</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> qreigvals</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> qrdec(A):</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> A.shape[<span class="dv">0</span>]</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>    Ap <span class="op">=</span> np.copy(A)</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> np.zeros((n,n))</span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> np.zeros((n,n))</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(j):</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>            R[i,j] <span class="op">=</span> Q[:,i]<span class="op">@</span>A[:,j]</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>            Ap[:,j] <span class="op">-=</span> R[i,j]<span class="op">*</span>Q[:,i]</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>        R[j,j] <span class="op">=</span> mag(Ap[:,j])</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>        Q[:,j] <span class="op">=</span> Ap[:,j]<span class="op">/</span>R[j,j]</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Q, R</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mag(xs):</span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.sqrt(np.<span class="bu">sum</span>(xs<span class="op">*</span>xs))</span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">'__main__'</span>:</span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>    np.set_printoptions(precision<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>    H <span class="op">=</span> threespins(<span class="fl">1.</span>,<span class="fl">2.</span>,<span class="fl">3.</span>,<span class="fl">0.5</span>)</span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>    qreigvals <span class="op">=</span> qrmet(H)<span class="op">;</span> <span class="bu">print</span>(qreigvals)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[-2.625 -2.201 -1.151  1.978 -0.022  0.849 -0.201  3.375]</code></pre>
</div>
</div>
</section>
</section>
</section>
<section id="homework" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Homework</h1>
<ol type="1">
<li>(no programming) Please derive <a href="#eq-two-spin">Equation&nbsp;3</a> from <a href="#eq-two-spin-tensor">Equation&nbsp;2</a>.</li>
<li>(no programming) Please prove the Kronecker product for arbitrary matrices satisfies <span class="math display">
(\boldsymbol{A}\otimes \boldsymbol{B})(\boldsymbol{C}\otimes \boldsymbol{D})
= (\boldsymbol{A}\boldsymbol{C}) \otimes (\boldsymbol{B}\boldsymbol{D}).
</span> Note that <span class="math inline">(\boldsymbol{A}\otimes \boldsymbol{B})(\boldsymbol{C}\otimes \boldsymbol{D})</span> is a matrix product between <span class="math inline">\boldsymbol{A}\otimes \boldsymbol{B}</span> and <span class="math inline">\boldsymbol{C}\otimes \boldsymbol{D}</span>, and <span class="math inline">\boldsymbol{A}\boldsymbol{C}</span> is the matrix product between <span class="math inline">\boldsymbol{A}</span> and <span class="math inline">\boldsymbol{C}</span>.</li>
<li>(programming) Take the two particle Hamiltonian. Fix <span class="math inline">\omega_{II}=2\omega_{I}</span>, and <span class="math inline">\gamma = 1</span>. Plot the eigenvalues as a function of <span class="math inline">\omega_I</span> in an interval <span class="math inline">0\leq \omega_I \leq 3.0</span>.</li>
</ol>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>